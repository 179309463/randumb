require 'active_support/core_ext/module/delegation'
require 'active_record/relation'

module Randumb
  # https://github.com/rails/rails/blob/master/activerecord/lib/active_record/relation/query_methods.rb
  module ActiveRecord

    module Relation

      # If the max_items argument is omitted, one random entity will be returned.
      # If you provide the integer argument, you will get back an array of records.
      def random(max_items = nil, seed = nil)
        random_weighted(nil, max_items, seed)
      end

      # If ranking_column is provided, that named column wil be multiplied
      # by a random number to determine probability of order. The ranking column must be numeric.
      def random_weighted(ranking_column, max_items = nil, seed = nil)
        relation = clone
        return random_by_id_shuffle(max_items, seed) if is_randumb_postges_case?(relation, ranking_column)
        raise_unless_valid_ranking_column(ranking_column)
        # get clause for current db type
        order_clause = random_order_clause(ranking_column, seed)

        the_scope = if ::ActiveRecord::VERSION::MAJOR == 3 && ::ActiveRecord::VERSION::MINOR < 2
          # AR 3.0.0 support
          relation.order(order_clause)
        else
          # keep prior orders and append random
          all_orders = (relation.orders + [order_clause]).join(", ")
          # override all previous orders
          relation.reorder(all_orders) 
        end
        
        # override the limit if they are requesting multiple records
        if max_items && (!relation.limit_value || relation.limit_value > max_items)
          the_scope = the_scope.limit(max_items)
        end

        # return first record if method was called without parameters
        max_items ? the_scope.to_a : the_scope.first
      end


      # This was my first implementation, adding it as an option for people to use
      # and to fall back on for pesky DB one off situations...
      #    https://github.com/spilliton/randumb/issues/7
      def random_by_id_shuffle(max_items = nil, seed = nil)
        return_first_record = max_items.nil? # see return switch at end
        max_items ||= 1
        relation = clone
        ids = fetch_random_ids(relation, max_items, seed)

        # build new scope for final query
        the_scope = klass.includes(includes_values)

        # specifying empty selects caused bug in rails 3.0.0/3.0.1
        the_scope = the_scope.select(select_values) unless select_values.empty?

        # get the records and shuffle since the order of the ids
        # passed to where() isn't retained in the result set
        rng = seed ? Random.new(seed) : Random.new
        records = the_scope.where(:id => ids).shuffle!(:random => rng)

        # return first record if method was called without parameters
        return_first_record ? records.first : records
      end

      private

      # postgres won't let you do an order_by when also doing a distinct
      # let's just use the in-memory option in this case
      def is_randumb_postges_case?(relation, ranking_column)
        if relation.respond_to?(:uniq_value) && relation.uniq_value && connection.adapter_name =~ /(postgres|postgis)/i
          if ranking_column
            raise Exception, "random_weighted: not possible when using .uniq and the postgres/postgis db adapter"
          else
            return true
          end
        end
      end

      # columns used for ranking must be a numeric type b/c they are multiplied
      def raise_unless_valid_ranking_column(ranking_column)
        if ranking_column
          column_data = @klass.columns_hash[ranking_column.to_s]
          raise ArgumentError.new("random_weighted: #{ranking_column} is not a column on #{@klass.table_name}!") unless column_data
          raise ArgumentError.new("random_weighted: #{ranking_column} is not a numeric column on #{@klass.table_name}!") unless [:integer, :float].include?(column_data.type)
        end
      end

      # sligtly different for each DB
      def random_syntax(seed)
        if connection.adapter_name =~ /(sqlite)/i
          if seed
            # SQLLite does not support a random seed.  However, pseudo-randomness
            # can be achieved by sorting on a hash of the id field (generated by 
            # multiplying the id by the random seed and ignoring everything before
            # the decimal).
            # See http://stackoverflow.com/questions/2171578/seeding-sqlite-random
            seed_value = Random.new(seed.to_i).rand
            "(SUBSTR(#{table_name}.id * #{seed_value}, LENGTH(#{table_name}.id) + 2))"
          else
            "RANDOM()"
          end
        elsif connection.adapter_name =~ /(postgres|postgis)/i
          # Postgres random seeding requires executing an extra "SELECT SETSEED(value)" on the connection.
          # See http://www.postgresql.org/docs/8.3/static/sql-set.html:
          #
          #     Sets the internal seed for the random number generator (the
          #     function random). Allowed values are floating-point numbers
          #     between 0 and 1, which are then multiplied by 2^(31)-1.
          #
          if seed
            seed_value = Random.new(seed.to_i).rand # map integer seed to a value: 0 <= value < 1
            connection.execute "SELECT SETSEED(#{seed_value})"
          end
          "RANDOM()"
        elsif connection.adapter_name =~ /mysql/i
          "RAND(#{seed.try(:to_i)})"
        else
          raise Exception, "ActiveRecord adapter: '#{connection.adapter_name}' not supported by randumb.  Send a pull request or open a ticket: https://github.com/spilliton/randumb"
        end
      end

      # builds the order clause to be appended in where clause
      def random_order_clause(ranking_column, seed)
        if ranking_column.nil?
          random_syntax(seed)
        else
          if connection.adapter_name =~ /sqlite/i
            # computer multiplication is faster than division I was once taught...so translate here
            max_int = 9223372036854775807.0
            multiplier = 1.0 / max_int
            "(#{ranking_column} * ABS(#{random_syntax(seed)} * #{multiplier}) ) DESC"
          else
            "(#{ranking_column} * #{random_syntax(seed)}) DESC"
          end
        end
      end

      # Returns all matching ids from the db, shuffles them,
      # then returns an array containing at most max_ids
      def fetch_random_ids(relation, max_ids, seed)
        # clear these for our id only query
        relation.select_values = []
        relation.includes_values = []

        # do original query but only for id field
        id_only_relation = relation.select("#{table_name}.id")

        id_results = connection.select_all(id_only_relation.to_sql)

        rng = seed ? Random.new(seed) : Random.new
        if max_ids == 1 && id_results.count > 0
          [ id_results[ rng.rand(id_results.count) ]['id'] ]
        else
          # ActiveRecord 4 requires .to_ary
          arr = id_results.respond_to?(:to_ary) ? id_results.to_ary : id_results
          arr.shuffle!(:random => rng)[0,max_ids].collect!{ |h| h['id'] }
        end
      end

    end


    # Class methods
    module Base
      def random(max_items = nil, seed = nil)
        relation.random(max_items, seed)
      end

      def random_weighted(ranking_column, max_items = nil, seed = nil)
        relation.random_weighted(ranking_column, max_items, seed)
      end

      def random_by_id_shuffle(max_items = nil, seed = nil)
        relation.random_by_id_shuffle(max_items, seed)
      end
    end


    # These get registered as class and instance methods
    module MethodMissingMagicks
      def method_missing(symbol, *args)
        if symbol.to_s =~ /^random_weighted_by_(\w+)$/
          random_weighted($1, *args)
        else
          super
        end
      end

      def respond_to?(symbol, include_private=false)
        if symbol.to_s =~ /^random_weighted_by_(\w+)$/
          true
        else
          super
        end
      end
    end

  end # ActiveRecord
end # Randumb
